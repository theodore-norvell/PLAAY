Keyboard shortcuts example
    Call( Var[f], CallWorld[+]( CallWorld[*]( Var[a], Var[b] ),
                                CallWorld[*]( Var[c], Var[d] ) ),
                  Var[e] )
 
I.e. f( (a*b) + (c*d), e )
Infix Sequence:
    Action   Comment/State
             !^
    f        Start Var node
             !Open Var[f]^
    enter    Close and select the Var node
             !Var[f]^
    @        Engulf with a Call and move to next dropzone
             Call( Var[f], !^ )
    a        Start a Var node
             Call( Var[f], !Open Var[a]^ )
    enter    Close and select the Var node
             Call( Var[f], !Var[a]^ )
    *        Engulf with a CallWorld and select the next PlaceHolder
             Call( Var[f], CallWorld[*]( Var[a], !ExpPH^ )
    b        Start a Var node
             Call( Var[f], CallWorld[*]( Var[a], !Open Var[b]^ )
    enter    Close and select the Var node
             Call( Var[f], CallWorld[*]( Var[a], !Var[b]^ )
    space    Select parent
             Call( Var[f], !CallWorld[*]( Var[a], Var[b] )^
    +        Engulf with a CallWorld and select the next PlaceHolder
             Call( Var[f], CallWorld[+]( CallWorld[*]( Var[a], Var[b] ), !ExpPH^ )
    c        Start a Var node
             Call( Var[f], CallWorld[+]( CallWorld[*]( Var[a], Var[b] ), !Open Var[c]^ )
    enter    Close and select the Var node
             Call( Var[f], CallWorld[+]( CallWorld[*]( Var[a], Var[b] ), !Var[c]^ )
    *        Engulf with a CallWorld and select the next PlaceHolder
             Call( Var[f], CallWorld[+]( CallWorld[*]( Var[a], Var[b] ),
                                         CallWorld[*]( Var[c], !ExpPH^ )
    d        Start a Var node
             Call( Var[f], CallWorld[+]( CallWorld[*]( Var[a], Var[b] ),
                                         CallWorld[*]( Var[c], !Open Var[d]^ ) )
    enter    Close and select the Var node
             Call( Var[f], CallWorld[+]( CallWorld[*]( Var[a], Var[b] ),
                                         CallWorld[*]( Var[c], !Var[d]^ ) )
    Escape   Go up to parent and then right to next place-holder or dropzone
             Call( Var[f], CallWorld[+]( CallWorld[*]( Var[a], Var[b] ),
                                         CallWorld[*]( Var[c], Var[d] ) ^!  )
    e        Start a Var node
             Call( Var[f], CallWorld[+]( CallWorld[*]( Var[a], Var[b] ),
                                         CallWorld[*]( Var[c], Var[d] ),
                           !Open Var[e]^ )
    enter    Close and select the Var node
             Call( Var[f], CallWorld[+]( CallWorld[*]( Var[a], Var[b] ),
                                         CallWorld[*]( Var[c], Var[d] ),
                           !Var[e]^ )

Prefix sequence for (a*b) + (c*d)
    Action   Comment/State
             ^!
    +        Replace with CallWorld
             CallWorld[+]( !ExpPH^, ExpPH )
    *        Engulf the ExpPH with CallWorld
             CallWorld[+]( CallWorld[*]( !ExpPH^, ExpPH ),
                           ExpPH )
    a        Start a Var node
             CallWorld[+]( CallWorld[*]( !Open Var[a]^, ExpPH ),
                           ExpPH )
    tab      Close and select next PH
             CallWorld[+]( CallWorld[*]( Var[a], !ExpPH^ ),
                           ExpPH )
    b        Start a Var node
             CallWorld[+]( CallWorld[*]( Var[a], !Open Var[b]^ ),
                           ExpPH )
    tab      Close and select next PH
             CallWorld[+]( CallWorld[*]( Var[a], Var[b] ),
                           !ExpPH^ )
    *        Engulf the ExpPH with CallWorld
             CallWorld[+]( CallWorld[*]( Var[a], Var[b] ),
                            CallWorld[*]( !ExpPH^, ExpPH ) )
    c        Start a Var node
             CallWorld[+]( CallWorld[*]( Var[a], Var[b] ),
                            CallWorld[*]( !open Var[c]^, ExpPH ) )
    tab      Close and select next PH
             CallWorld[+]( CallWorld[*]( Var[a], Var[b] ),
                            CallWorld[*]( Var[c], !ExpPH^ ) )
    d        Start a Var node
             CallWorld[+]( CallWorld[*]( Var[a], Var[b] ),
                            CallWorld[*]( Var[c], !open Var[d]^) )
    enter
             CallWorld[+]( CallWorld[*]( Var[a], Var[b] ),
                            CallWorld[*]( Var[c], !Var[d]^) )
 
 Many user actions such as keypresses, click on palette buttons, and drag and drop from the palette create compound nodes; i.e., nodes that can have children.
 Examples:
    Pressing the + * - / @ \ 0 . or ? keys.
    Dragging the ?, while, lambda, varDecl, call or callWorld pallet items onto the view of the tree.
    Clicking on any of the same buttons.

 Each of these actions can be interpreted as replacing or engulfing the current selection.  The rules to decide are these
    * If both edits would fail, no change to the tree.
    * If only one edit would succeed, that edit is chosen.
    * If the current selection is empty, replace is preferred.
    * If the current selection is not empty, engulf is preferred.

These rules are easily expressed by the edit
    alt( compose( selectionIsEmpty, replace ), alt( engulf, replace) )
where
   * alt and compose are as defined in the edits module,
   * selectionIsEmpty is an edit that fails if the selection is not empty
     and makes no change if the selection is empty,
   * replace is an edit that replaces the current selection with the new tree,
   * and engulf is an edit that engulfs the current selection with the new tree.

Details of replace. A replace can be though of as two edit steps. Suppose the target
(i.e., the argument to apply) is t and the template to be inserted is another selection s.
Let ps be the sequence of nodes selected by t.
*  First the ps in t are replaced by s (ala InsertChildrenEdit) to make a selection t'.
*  If the first step fails the whole edit fails.
*  Second a TabEdit is done to t' to get a slection t''.

Details of engulf.  An engulf can be thought of as three edit steps.  Suppose the target
(i.e., the argument to apply) is t and the template to be inserted is another selection s.
Let ps be the sequence of nodes selected by t.
*  First ps is inserted (ala InsertChildrenEdit) into s to make a selection s'.
*  If the first step fails, the whole edit fails.
*  Second the root of s' is inserted into t (ala InsertChildrenEdit) to make a
   selection t'.  t' should have one selected, node, corresponding to the root of s'.
*  The second step fails, the whole edit fails.
*  Third. If possible a RightEdit edit is applied to t' giving a result of t''.
*  The result is t'' if the RightEdit succeeds and is t' if the RightEdit fails.

Details of TabEdit.  A TabEdit repeatedly moves the selection right in previsit order at least
once.  It stops moving the selection right when the selection is either a point selection
corresponding to a dropzone or a placeholder.

Details of space.  A space expands the current selection by selecting the parent, unless
the parent is the root, in which case there is no change.
